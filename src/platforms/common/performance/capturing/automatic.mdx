---
title: Automatic Instrumentation
sidebar_order: 10
supported:
  - javascript
  - react-native
description: "Learn how to add automatic instrumentation to captured transactions."
---

<Note>

To _automatically_ capture transactions, you must first <PlatformLink to="/performance/">enable tracing in your app.</PlatformLink>

</Note>

The `@sentry/react-native` provides a `ReactNativeTracing` integration to add _automatic_ instrumentation for monitoring the performance of React Native applications.

## What Automatic Instrumentation Provides

The `ReactNativeTracing` creates a child span for every `XMLHttpRequest` or `fetch` request on the Javascript layer that occurs while those transactions are open. Learn more about [traces, transactions, and spans](/product/performance/distributed-tracing/).

## Enable Automatic Instrumentation

To enable this automatic tracing, include the `ReactNativeTracing` integration in your SDK configuration options.

```javascript
import * as Sentry from "@sentry/react-native";

Sentry.init({
  dsn: "___PUBLIC_DSN___",

  integrations: [
    new Sentry.ReactNativeTracing({
      tracingOrigins: ["localhost", "my-site-url.com", /^\//],
      // ... other options
    }),
  ],

  // We recommend adjusting this value in production, or using tracesSampler
  // for finer control
  tracesSampleRate: 1.0,
});
```

## Configuration Options

You can pass many different options to the `ReactNativeTracing` integration (as an object of the form `{optionName: value}`), but it comes with reasonable defaults out of the box. For all possible options, see [TypeDocs](https://getsentry.github.io/sentry-javascript/interfaces/tracing.browsertracingoptions.html).

### tracingOrigins

The default value of `tracingOrigins` is `['localhost', /^\//]`. The React Native SDK will attach the `sentry-trace` header to all outgoing XHR/fetch requests whose destination contains a string in the list or matches a regex in the list. If your frontend is making requests to a different domain, you will need to add it there to propagate the `sentry-trace` header to the backend services, which is required to link transactions together as part of a single trace. **The `tracingOrigins` option matches against the whole request URL, not just the domain. Using stricter regex to match certain parts of the URL ensures that requests do not unnecessarily have the `sentry-trace` header attached.**

<PlatformContent includePath="performance/tracingOrigins-example" />

You will need to configure your web server CORS to allow the `sentry-trace` header. The configuration might look like `"Access-Control-Allow-Headers: sentry-trace"`, but the configuration depends on your set up. If you do not allow the `sentry-trace` header, the request might be blocked.

### shouldCreateSpanForRequest

This function can be used to filter out unwanted spans such as XHR's running health checks or something similar. By default `shouldCreateSpanForRequest` already filters out everything but what was defined in `tracingOrigins`.

<PlatformContent includePath="performance/filter-span-example" />

## Enable Routing Instrumentation

In our React Native, we currently provide two routing instrumentations out of the box for React Navigation V5 and V4. Otherwise you can use the bare bones routing instrumentation or create your own.

### React Navigation V5

Note that this routing instrumentation will create a transaction on every route change including `goBack` navigations.

```js
import * as Sentry from "@sentry/react-native";

// Construct a new instrumentation instance. This is needed to communicate between the integration and React
const reactNavigationV5Instrumentation = new Sentry.ReactNavigationV5Instrumentation();

Sentry.init({
  ...
  integrations: [
    new Sentry.ReactNativeTracing({
      // Pass instrumentation to be used as `routingInstrumentation`
      routingInstrumentation: reactNavigationV5Instrumentation,
      // ...
    }),
  ],
})

const App = () => {
  // Create a ref for the navigation container
  const navigation = React.createRef<NavigationContainerRef>();

  // Register the navigation container with the instrumentation
  React.useEffect(() => {
    reactNavigationV5Instrumentation.registerNavigationContainer(navigation);
  }, []);

  return (
    // Connect the ref to the navigation container
    <NavigationContainer ref={navigation}>
      ...
    </NavigationContainer>
  );
};
```

#### Configuration Options

You can configure this instrumentation by passing an object as the first argument to `ReactNavigationV5Instrumentation`:

`shouldSendTransaction` (route, previousRoute) => boolean

```js
const reactNavigationV5Instrumentation = new Sentry.ReactNavigationV5Instrumentation(
  {
    shouldSendTransaction: (route, previousRoute) => {
      if (route.name === "Ignore-Route") {
        return false;
      }

      if (route.params.containsSensitiveInfo) {
        return false;
      }

      if (previousRoute.name === "ShouldIgnoreAfter") {
        return false;
      }

      return true;
    },
  }
);

// ...
```

### React Navigation V4

Note that this routing instrumentation will create a transaction on every route change including `goBack` navigations.

```js
// Construct a new instrumentation instance. This is needed to communicate between the integration and React
const reactNavigationV4Instrumentation = new Sentry.ReactNavigationV4Instrumentation();

Sentry.init({
  ...
  integrations: [
    new Sentry.ReactNativeTracing({
      // Pass instrumentation to be used as `routingInstrumentation`
      routingInstrumentation: reactNavigationV4Instrumentation,
      ...
    }),
  ],
})

const App = () => {
  // Create a ref for the navigation container
  const appContainer = React.createRef();

  // Register the navigation container with the instrumentation
  React.useEffect(() => {
    reactNavigationV4Instrumentation.registerAppContainer(appContainer);
  }, []);

  return (
    // Connect the ref to the navigation container
    <AppContainer ref={appContainer} />
  );
};
```

#### Configuration Options

You can configure this instrumentation by passing an object as the first argument to `ReactNavigationV4Instrumentation`:

`shouldSendTransaction` (route, previousRoute) => boolean

```js
const reactNavigationV4Instrumentation = new Sentry.ReactNavigationV4Instrumentation(
  {
    shouldSendTransaction: (route, previousRoute) => {
      // Note that it is route.routeName here and NOT route.name like in V5, this is directly from React-Navigation
      if (route.routeName === "Ignore-Route") {
        return false;
      }

      if (route.params.containsSensitiveInfo) {
        return false;
      }

      if (previousRoute.name === "ShouldIgnoreAfter") {
        return false;
      }

      return true;
    },
  }
);

// ...
```

### Other Navigation Libraries or Custom Navigation

If you use another navigation library that we don't support or have a custom navigation solution, you can use our basic `RoutingInstrumentation` or extend it to create your own class.

Every routing instrumentation revoles around one method:

`onRouteWillChange` (context: TransactionContext): Transaction | undefined

You need to ensure that this method is called **before** the route change occurs.

#### Usage

```js
// Construct a new instrumentation instance. This is needed to communicate between the integration and React
const routingInstrumentation = new Sentry.RoutingInstrumentation();

Sentry.init({
  ...
  integrations: [
    new Sentry.ReactNativeTracing({
      // Pass instrumentation to be used as `routingInstrumentation`
      routingInstrumentation,
      ...
    }),
  ],
})

const App = () => {
  <SomeNavigationLibrary
    onRouteWillChange={(newRoute) => {
        // Call this before the route changes
      routingInstrumentation.onRouteWillChange({
        name: newRoute.name,
        op: 'navigation'
      })
    }}
  />
};
```

#### Extending

```js
class CustomInstrumentation extends RoutingInstrumentation {
  constructor(navigator) {
    super();

    this.navigator.registerRouteChangeListener(this.routeListener.bind(this));
  }

  routeListener(newRoute) {
    // Again, ensure this is called BEFORE the route changes and BEFORE the route is mounted.
    this.onRouteWillChange({
      name: newRoute.name,
      op: "navigation",
    });
  }
}
```

More extensive extension examples is by looking at our code for the React Navigation instrumentations.
